	ll power[maxn];//power[i]记录p的i次方
    ll hash_mod = 1e12 + 39;
    int p = 131;
	power[0] = 1;
	rep(i, 1, maxn){
        power[i] = (power[i - 1] * p) % hash_mod;
    }
	auto get_hash = [&](string s){
		ll res = 0;
		rep(i, 1, s.size() + 1){
    		res = (res * p + s[i - 1] - 'a' + 1) % hash_mod;
    	}
    	return res;
	};
    auto get = [&](int l, int r){// hash_mod = 1e9 + 7
		ll res = (Hash[r] - Hash[l - 1] * power[r - l + 1]) % hash_mod;
		while(res < 0) res += hash_mod;
		return res % hash_mod;
	};

typedef pair<int,int> hashv;
const ll mod1 = 1000000007;
const ll mod2 = 1000000009;
mt19937 mrand(random_device{}()); 
int rnd(int x) {return mrand() % x;}
hashv operator + (hashv a,hashv b) {
	int c1 = a.fi + b.fi, c2 = a.se + b.se;
	if (c1 >= mod1) c1 -= mod1;
	if (c2 >= mod2) c2 -= mod2;
	return make_pair(c1, c2);
}
 
hashv operator - (hashv a,hashv b) {
	int c1 = a.fi - b.fi, c2 = a.se - b.se;
	if (c1 < 0) c1 += mod1;
	if (c2 < 0) c2 += mod2;
	return make_pair(c1, c2);
}
 
hashv operator * (hashv a,hashv b) {
	return make_pair(1ll * a.fi * b.fi % mod1, 1ll * a.se * b.se % mod2);
}