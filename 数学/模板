int gcd(int a, int b){
    return b ? gcd(b, a % b) : a;
}
int exgcd(int a, int b, int& x, int& y){// ax + by = gcd(a, b)
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int ans = exgcd(b, a % b, x, y);
    int t = x;
    x = y;
    y = t - (a / b) * y;
    return ans;//返回最大公约数
    // x 和 y 是 ax + by = gcd(a, b) 的一组解
}
void get_prim(int num){//线性筛素数
    cnt = 0;
    memset(v, 0, sizeof v);
    for(int i = 2; i <= num; i++){
        if(!v[i]) prim[cnt++] = i;
        for(int j = 0; j < cnt; j++){
            v[prim[j] * i] = prim[j]; // if(!v[i]) i 为质数
            if(prim[j] > v[i] || prim[j] > num / i) break;       
        }
    }
}
ll mul(ll a, ll b, ll p){//快速乘
    ll res = 0, t = a % p;
    while(b){
        if(b & 1) res = (res + t) % p;
        b >>= 1;
        t = (t + t) % p;
    }
    return res;
}
ll qmi(ll a, ll b, ll p){//龟速幂
    ll ans = 1, t = a;
    while(b){
        if(b & 1) ans = mul(ans, t, p);//龟速乘防止爆long long
        t = mul(t, t, p);
        b >>= 1;
    }
    return ans;
}
ll get_euler(ll x){//欧拉函数
    ll ans = x;
    for(int i = 2; i * i <= x; i++){
        if(x % i == 0){
            ans = ans / i * (i - 1);
            while(x % i == 0) x /= i;
        }
    }
    if(x > 1) ans = ans / x * (x - 1);
    return ans;
}
int c(int n, int k, int mod){//求大组合数
    _rep(i, 0, n + 1) fac[i] = i ? fac[i - 1] * i % mod : 1;
	_rep(i, 1, n + 1) inv[i] = i == 1 ? 1 : (mod - mod / i) * inv[mod % i] % mod;//求i的乘法逆元
	_rep(i, 0, n + 1) inv[i] = i ? inv[i - 1] * inv[i] % mod : 1;//求i! 的乘法逆元
    return fac[n] * inv[k] % mod * inv[n - k] % mod;
}